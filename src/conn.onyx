//+optional-semicolons

package websockets

use core.io
use core {Result}
use core.sync
use core.slice
use core.array

Conn :: struct {
    stream: &io.Stream

    open: bool

    type: ConnType
    mutex: sync.Mutex

    last_checkin: u64
}

ConnType :: enum {
    Server :: 1
    Client :: 2
}

ConnError :: enum {
    None
    BadProtocol
    NotImplemented
}

Conn.make_from_stream :: (stream: &io.Stream, type: ConnType) -> (conn: Conn) {
    conn.stream = stream
    conn.open = true
    conn.type = type
    sync.mutex_init(&conn.mutex)
    return
}

Conn.close :: (conn: &Conn) -> ConnError {

    return .None
}

Conn.send :: (conn: &Conn, data: [] u8) -> ConnError {

    return .None
}

Conn.recv :: (conn: &Conn) -> Result([] u8, ConnError) {
    consumer := FrameConsumer.{
        conn,
        make([..] u8)
    }

    consumer->consume_all_frames()

    if consumer.should_close {
        conn->close()
        return .{ Err = .BadProtocol }
    }

    return .{ Ok = consumer.buf }
}

#local
FrameHeader :: struct {
    fin: bool
    opcode: FrameOpcode
    payload_length: u64
    masking_key: ? [4] u8
}

#local
FrameOpcode :: enum {
    Continuation :: 0
    Text         :: 1
    Binary       :: 2
    Close        :: 8
    Ping         :: 9
    Pong         :: 10
}

#local
FrameConsumer :: struct {
    conn: &Conn

    buf: [..] u8

    ping_encountered := false
    pong_encountered := false

    should_close := false
}

FrameConsumer.consume_all_frames :: (self: &#Self) {
    while true {
        header := read_frame_header(self.conn.stream)?

        if header.opcode == .Ping do self.ping_encountered = true
        if header.opcode == .Pong do self.pong_encountered = true

        if header.opcode == .Text ||
           header.opcode == .Binary ||
           header.opcode == .Continuation
        {
            use new_data := make([] u8, ~~header.payload_length)

            err, _ := io.stream_read_until_full(self.conn.stream, new_data)
            if err != .None do return

            header.masking_key->with([key] {
                // Connections living on the server (from the client)
                // should not have a masking key, and if they do,
                // the connection must be closed.
                if self.conn.type != .Server {
                    self.should_close = true
                }

                apply_mask(new_data, key)
            })

            array.concat(&self.buf, new_data)

            if header.fin do break
        }

        if header.opcode == .Close {
            // TODO: Handle the socket close case
            self.should_close = true
        }
    }
}

#local
read_frame_header :: (s: &io.Stream) -> ? FrameHeader {
    header: FrameHeader

    data: [8] u8
    err, data_len := io.stream_read_until_full(s, data[0 .. 2])
    if err != .None || data_len == 0 do return .None

    header.fin    =   (data[0] & 0x80) != 0
    header.opcode = ~~(data[0] & 0x0F)

    has_mask             :=   (data[1] & 0x80) != 0
    header.payload_length = ~~(data[1] & 0x7F)

    if header.payload_length == 126 {
        err, data_len := io.stream_read_until_full(s, data[0 .. 2])
        if err != .None || data_len == 0 do return .None

        slice.reverse(data[0 .. 2])

        header.payload_length = ~~ *cast(&u16) data
    }
    elseif header.payload_length == 127 {
        err, data_len := io.stream_read_until_full(s, data)
        if err != .None || data_len == 0 do return .None

        slice.reverse(data)

        header.payload_length = ~~ *cast(&u64) data
    }

    if has_mask {
        err, data_len := io.stream_read_until_full(s, data[0 .. 4])
        if err != .None || data_len == 0 do return .None

        header.masking_key = *cast(&[4] u8) data
    }

    return header
}


#local
apply_mask :: (data: [] u8, key: [4] u8) {
    for &d, index in data {
        *d = *d ^ key[index % 4]
    }
}

